# Лабораторная работа №3

## Использованные алгоритмы интерполяции

---
**Выполнила:** Гаврилович Вероника Вячеславовна 
**Группа:** Р3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure
---


### Задача
Реализовать потоковую интерполяцию с поддержкой нескольких алгоритмов:
- Линейная интерполяция отрезками
- Интерполяция Ньютона

### Линейная интерполяция
Аппроксимация между узлами осуществляется линейной функцией:

$$y = y_1 + \frac{x - x_1}{x_2 - x_1} \cdot (y_2 - y_1)$$

Используется для приближённого вычисления значения функции между двумя известными точками.
Формула:

$$t = \frac{x - x_1}{x_2 - x_1}$$

$$y = y_1 + t (y_2 - y_1)$$

---

### **2. Интерполяция полиномом Ньютона**

Используется полином в форме Ньютона:

$$P(x)=a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1) + \ldots$$

Коэффициенты вычисляются через таблицу разделённых разностей:

$f[x_i] = y_i$

$f[x_i, x_{i+1}] = \frac{f[x_{i+1}] - f[x_i]}{x_{i+1}-x_i}$

$f[x_i, x_{i+1}, x_{i+2}] =
\frac{f[x_{i+1},x_{i+2}] - f[x_i,x_{i+1}]}
{x_{i+2} - x_i}$

Последовательность первых элементов каждой строки таблицы разностей формирует коэффициенты
([a_0, a_1, a_2, …]).

Вычисление значения полинома выполняется по схеме Горнера для формы Ньютона:

$P(x) = a_0 + (x - x_0)\big[a_1 + (x - x_1)[a_2 + \cdots]\big]$

---


## Ключевые элементы реализации
## Модуль `interpolation`
- find-segment - Находит пару соседних точек [p1 p2], таких что x1 <= x <= x2

``` Clojure
(defn compute-linear
  "Линейная интерполяция: возвращает y или nil."
  [points x]
  (when-let [[p1 p2] (find-segment points x)]
    (let [x1 (:x p1)
          y1 (:y p1)
          x2 (:x p2)
          y2 (:y p2)]
      (if (= x1 x2)
        y1
        (let [t (/ (- x x1) (- x2 x1))]
          (+ y1 (* t (- y2 y1))))))))
```

Выполняет линейную интерполяцию по найденному сегменту.
Возвращает интерполированное `y` или `nil`.

- choose-window - Выбирает окно из `n` точек, ближайших к значению `x`, для интерполяции Ньютона. Гарантирует, что окно остаётся внутри массива точек.
- calc-coefficients - Строит таблицу разделённых разностей. Возвращает вектор коэффициентов полинома Ньютона: `[a0 a1 a2 ...]`.
- newton-eval - Вычисляет значение полинома Ньютона в точке `x`, используя схему Горнера.

``` Clojure
(defn compute-newton
  "Расчёт y методом Ньютона"
  [points n x]
  (let [window (choose-window points n x)
        coeffs (calc-coefficients window)]
    (newton-eval coeffs window x)))
```

Обёртка для вычисления методом Ньютона:
— выбирает окно
— вычисляет разделённые разности
— вычисляет значение полинома

- ready? - Проверяет, достаточно ли точек для выбранного вида интерполяции.
- interpolate-at-x - Вычисляет интерполяцию (линейную и/или ньютоновскую) в одной точке `x`. Возвращает список структур:
`{:alg :linear :x x :y y}`
`{:alg :newton :x x :y y}`.

- produce-outputs - Генерирует результаты интерполяции на промежутке `[next-x, max-x]` с шагом `step`.
- handle-datapoint - Принимает новую точку входного потока. Обновляет состояние и вычисляет новые выходные значения.

---

## Модуль `core`

- parse-dbl/int - обертки для красоты для парсинга строки в double/int.
- parse-args - Парсер аргументов командной строки.
``` Clojure
(defn parse-args
  "Парсер аргументов командной строки"
  [args]
  (loop [m    {:linear? false
               :newton? false
               :step    1.0
               :n       4}
         args args]
    (if (empty? args)
      (do
        (when (and (not (:linear? m))
                   (not (:newton? m)))
          (binding [*out* *err*]
            (println "Error: at least one of --linear or --newton must be given"))
          (System/exit 1))
        (when (<= (:step m) 0)
          (binding [*out* *err*]
            (println "Error: --step must be > 0"))
          (System/exit 1))
        m)

      (let [[a & rest-args] args]
        (cond
          (= a "--linear")
          (recur (assoc m :linear? true) rest-args)

          (= a "--newton")
          (recur (assoc m :newton? true) rest-args)

          (= a "--step")
          (recur (assoc m :step (parse-dbl (first rest-args)))
                 (rest rest-args))

          (or (= a "-n") (= a "--n"))
          (recur (assoc m :n (parse-int (first rest-args)))
                 (rest rest-args))

          :else
          (throw (ex-info (str "Unexpected argument: " a) {})))))))
```

Поддерживает параметры:
* `--linear` — включить линейную интерполяцию,
* `--newton` — включить интерполяцию Ньютона,
* `--step <число>` — задать шаг интерполяции,
* `-n <число>` или `--n <число>` — количество точек для Ньютона.


- parse-point - Парсит строку вида:

```
x y
x;y
x,y
```

Возвращает структуру `{:x ..., :y ...}` или `nil`.

- fmt3 - Форматирует число с 3 знаками после запятой, убирает лишние нули.

- -main
``` Clojure
(defn -main [& args]
  (let [opts (parse-args args)]
    (loop [state (interp/init-state)]
      (when-some [line (read-line)]
        (if-let [p (parse-point line)]
          (let [{:keys [state outputs]}
                (interp/handle-datapoint opts state p)]
            (doseq [{:keys [alg x y]} outputs]
              (println (format "%s: %s %s"
                               (name alg) (fmt3 x) (fmt3 y))))
            (recur state))
          (recur state))))))
```
Выполняет:

1. Парсинг аргументов.
2. Инициализацию состояния интерполятора.
3. Чтение строк из stdin.
4. Парсинг входных точек.
5. Вызов `handle-datapoint` для каждой новой точки.
6. Вывод всех вычисленных значений интерполяции.

Работает в потоковом режиме.

---

## Тесты
Были реализованы:
- property-based тесты (проверка монотонности и совпадения линейной интерполяции, как самой простой, с аналитическим значением);
- юнит тесты для каждого алгоритма на совпадение с ожидаемым результатом (interpolation-test)
- core тесты (проверяют корректность парсинга, обработку валидных/невалидных входных данных, корректность вывода и т.д.)
